// Automatically generated by isl_bindings_generator.
// LICENSE: MIT

use crate::bindings::{
    Context, DimType, Fold, Point, PwQPolynomial, PwQPolynomialFold, PwQPolynomialFoldList,
    PwQPolynomialList, Set, Space, Stat, UnionPwQPolynomialFold, UnionSet, Val,
};
use libc::uintptr_t;
use std::ffi::{CStr, CString};
use std::os::raw::{c_char, c_void};

/// Wraps `isl_union_pw_qpolynomial`.
pub struct UnionPwQPolynomial {
    pub ptr: uintptr_t,
    pub should_free_on_drop: bool,
}

extern "C" {

    fn isl_union_pw_qpolynomial_fold_eval(upwf: uintptr_t, pnt: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_coalesce(upwf: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_to_polynomial(upwqp: uintptr_t, sign: i32) -> uintptr_t;

    fn isl_union_pw_qpolynomial_find_dim_by_name(upwqp: uintptr_t, type_: DimType,
                                                 name: *const c_char)
                                                 -> i32;

    fn isl_union_pw_qpolynomial_fold_zero_ctx(ctx: uintptr_t, type_: Fold) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_dim(upwf: uintptr_t, type_: DimType) -> i32;

    fn isl_union_pw_qpolynomial_copy(upwqp: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_sub(upwqp1: uintptr_t, upwqp2: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_extract_pw_qpolynomial(upwqp: uintptr_t, space: uintptr_t)
                                                       -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_fold(upwf1: uintptr_t, upwf2: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_subtract_domain_union_set(upwpq: uintptr_t, uset: uintptr_t)
                                                          -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_get_pw_qpolynomial_fold_list(upwf: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_gist(upwf: uintptr_t, context: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_subtract_domain(upwf: uintptr_t, uset: uintptr_t)
                                                     -> uintptr_t;

    fn isl_union_pw_qpolynomial_add(upwqp1: uintptr_t, upwqp2: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_fold_pw_qpolynomial_fold(upwqp: uintptr_t, pwqp: uintptr_t)
                                                              -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_scale_val(upwf: uintptr_t, v: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_add_pw_qpolynomial(upwqp: uintptr_t, pwqp: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_subtract_domain_space(upwf: uintptr_t, space: uintptr_t)
                                                           -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_intersect_params(upwf: uintptr_t, set: uintptr_t)
                                                      -> uintptr_t;

    fn isl_union_pw_qpolynomial_intersect_params(upwpq: uintptr_t, set: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_coalesce(upwqp: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_get_ctx(upwqp: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_get_type(upwf: uintptr_t) -> Fold;

    fn isl_union_pw_qpolynomial_scale_val(upwqp: uintptr_t, v: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_intersect_domain_wrapped_domain(upwpq: uintptr_t, uset: uintptr_t)
                                                                -> uintptr_t;

    fn isl_union_pw_qpolynomial_subtract_domain(upwpq: uintptr_t, uset: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_zero(space: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_scale_down_val(upwf: uintptr_t, v: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_every_pw_qpolynomial(upwqp: uintptr_t,
                                                     test: unsafe extern "C" fn(uintptr_t,
                                                                          *mut c_void)
                                                                          -> i32,
                                                     user: *mut c_void)
                                                     -> i32;

    fn isl_union_pw_qpolynomial_fold_intersect_domain_wrapped_domain(upwf: uintptr_t,
                                                                     uset: uintptr_t)
                                                                     -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_copy(upwf: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_zero(space: uintptr_t, type_: Fold) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_foreach_pw_qpolynomial_fold(upwf: uintptr_t,
                                                                 fn_: unsafe extern "C" fn(uintptr_t, *mut c_void) -> Stat,
                                                                 user: *mut c_void)
                                                                 -> Stat;

    fn isl_union_pw_qpolynomial_zero_space(space: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_free(upwqp: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_get_pw_qpolynomial_list(upwqp: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_intersect_domain_space(upwf: uintptr_t, space: uintptr_t)
                                                            -> uintptr_t;

    fn isl_union_pw_qpolynomial_zero_ctx(ctx: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_intersect_domain_union_set(upwpq: uintptr_t, uset: uintptr_t)
                                                           -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_subtract_domain_union_set(upwf: uintptr_t, uset: uintptr_t)
                                                               -> uintptr_t;

    fn isl_union_pw_qpolynomial_mul(upwqp1: uintptr_t, upwqp2: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_get_space(upwf: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_subtract_domain_space(upwpq: uintptr_t, space: uintptr_t)
                                                      -> uintptr_t;

    fn isl_union_pw_qpolynomial_n_pw_qpolynomial(upwqp: uintptr_t) -> i32;

    fn isl_union_pw_qpolynomial_fold_gist_params(upwf: uintptr_t, context: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_neg(upwqp: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_drop_dims(upwf: uintptr_t, type_: DimType, first: u32, n: u32)
                                               -> uintptr_t;

    fn isl_union_pw_qpolynomial_to_str(upwqp: uintptr_t) -> *const c_char;

    fn isl_union_pw_qpolynomial_intersect_domain_wrapped_range(upwpq: uintptr_t, uset: uintptr_t)
                                                               -> uintptr_t;

    fn isl_union_pw_qpolynomial_involves_nan(upwqp: uintptr_t) -> i32;

    fn isl_union_pw_qpolynomial_fold_add_union_pw_qpolynomial(upwf: uintptr_t, upwqp: uintptr_t)
                                                              -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_free(upwf: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_reset_user(upwf: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_scale_down_val(upwqp: uintptr_t, v: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_drop_dims(upwqp: uintptr_t, type_: DimType, first: u32, n: u32)
                                          -> uintptr_t;

    fn isl_union_pw_qpolynomial_align_params(upwqp: uintptr_t, model: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_dim(upwqp: uintptr_t, type_: DimType) -> i32;

    fn isl_union_pw_qpolynomial_plain_is_equal(upwqp1: uintptr_t, upwqp2: uintptr_t) -> i32;

    fn isl_union_pw_qpolynomial_eval(upwqp: uintptr_t, pnt: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_intersect_domain(upwf: uintptr_t, uset: uintptr_t)
                                                      -> uintptr_t;

    fn isl_union_pw_qpolynomial_foreach_pw_qpolynomial(upwqp: uintptr_t,
                                                       fn_: unsafe extern "C" fn(uintptr_t,
                                                                            *mut c_void)
                                                                            -> Stat,
                                                       user: *mut c_void)
                                                       -> Stat;

    fn isl_union_pw_qpolynomial_read_from_str(ctx: uintptr_t, str_: *const c_char) -> uintptr_t;

    fn isl_union_pw_qpolynomial_domain(upwqp: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_gist_params(upwqp: uintptr_t, context: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_intersect_domain(upwpq: uintptr_t, uset: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_get_ctx(upwf: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_gist(upwqp: uintptr_t, context: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_intersect_domain_space(upwpq: uintptr_t, space: uintptr_t)
                                                       -> uintptr_t;

    fn isl_union_pw_qpolynomial_get_space(upwqp: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_reset_user(upwqp: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_involves_nan(upwf: uintptr_t) -> i32;

    fn isl_union_pw_qpolynomial_fold_intersect_domain_wrapped_range(upwf: uintptr_t,
                                                                    uset: uintptr_t)
                                                                    -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_domain(upwf: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_n_pw_qpolynomial_fold(upwf: uintptr_t) -> i32;

    fn isl_union_pw_qpolynomial_fold_from_pw_qpolynomial_fold(pwf: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_every_pw_qpolynomial_fold(upwf: uintptr_t,
                                                               test: unsafe extern "C" fn(uintptr_t, *mut c_void) -> i32,
                                                               user: *mut c_void)
                                                               -> i32;

    fn isl_union_pw_qpolynomial_set_dim_name(upwqp: uintptr_t, type_: DimType, pos: u32,
                                             s: *const c_char)
                                             -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_plain_is_equal(upwf1: uintptr_t, upwf2: uintptr_t) -> i32;

    fn isl_union_pw_qpolynomial_fold_set_dim_name(upwf: uintptr_t, type_: DimType, pos: u32,
                                                  s: *const c_char)
                                                  -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_extract_pw_qpolynomial_fold(upwf: uintptr_t, space: uintptr_t)
                                                                 -> uintptr_t;

    fn isl_union_pw_qpolynomial_from_pw_qpolynomial(pwqp: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_zero_space(space: uintptr_t, type_: Fold) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_align_params(upwf: uintptr_t, model: uintptr_t) -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_intersect_domain_union_set(upwf: uintptr_t, uset: uintptr_t)
                                                                -> uintptr_t;

    fn isl_union_pw_qpolynomial_fold_find_dim_by_name(upwf: uintptr_t, type_: DimType,
                                                      name: *const c_char)
                                                      -> i32;

}

impl Clone for UnionPwQPolynomial {
    fn clone(&self) -> UnionPwQPolynomial {
        self.copy()
    }
}

impl core::ops::Add for UnionPwQPolynomial {
    type Output = UnionPwQPolynomial;

    fn add(self, rhs: UnionPwQPolynomial) -> UnionPwQPolynomial {
        self.add(rhs)
    }
}

impl core::ops::Sub for UnionPwQPolynomial {
    type Output = UnionPwQPolynomial;

    fn sub(self, rhs: UnionPwQPolynomial) -> UnionPwQPolynomial {
        self.sub(rhs)
    }
}

impl core::ops::Mul for UnionPwQPolynomial {
    type Output = UnionPwQPolynomial;

    fn mul(self, rhs: UnionPwQPolynomial) -> UnionPwQPolynomial {
        self.mul(rhs)
    }
}

impl UnionPwQPolynomial {
    /// Wraps `isl_union_pw_qpolynomial_fold_eval`.
    pub fn fold_eval(upwf: UnionPwQPolynomialFold, pnt: Point) -> Val {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let mut pnt = pnt;
        pnt.do_not_free_on_drop();
        let pnt = pnt.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_eval(upwf, pnt) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = Val { ptr: isl_rs_result,
                                  should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_coalesce`.
    pub fn fold_coalesce(upwf: UnionPwQPolynomialFold) -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_coalesce(upwf) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_to_polynomial`.
    pub fn to_polynomial(self, sign: i32) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let mut upwqp = upwqp;
        upwqp.do_not_free_on_drop();
        let upwqp = upwqp.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_to_polynomial(upwqp, sign) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_find_dim_by_name`.
    pub fn find_dim_by_name(&self, type_: DimType, name: &str) -> i32 {
        let upwqp = self;
        let upwqp = upwqp.ptr;
        let name = CString::new(name).unwrap();
        let name = name.as_ptr();
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_find_dim_by_name(upwqp, type_, name) };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_zero_ctx`.
    pub fn fold_zero_ctx(ctx: &Context, type_: Fold) -> UnionPwQPolynomialFold {
        let ctx = ctx.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_zero_ctx(ctx, type_) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_dim`.
    pub fn fold_dim(upwf: &UnionPwQPolynomialFold, type_: DimType) -> i32 {
        let upwf = upwf.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_dim(upwf, type_) };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_copy`.
    pub fn copy(&self) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let upwqp = upwqp.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_copy(upwqp) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_sub`.
    pub fn sub(self, upwqp2: UnionPwQPolynomial) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwqp1 = self;
        let mut upwqp1 = upwqp1;
        upwqp1.do_not_free_on_drop();
        let upwqp1 = upwqp1.ptr;
        let mut upwqp2 = upwqp2;
        upwqp2.do_not_free_on_drop();
        let upwqp2 = upwqp2.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_sub(upwqp1, upwqp2) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_extract_pw_qpolynomial`.
    pub fn extract_pw_qpolynomial(&self, space: Space) -> PwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let upwqp = upwqp.ptr;
        let mut space = space;
        space.do_not_free_on_drop();
        let space = space.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_extract_pw_qpolynomial(upwqp, space) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = PwQPolynomial { ptr: isl_rs_result,
                                            should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_fold`.
    pub fn fold_fold(upwf1: UnionPwQPolynomialFold, upwf2: UnionPwQPolynomialFold)
                     -> UnionPwQPolynomialFold {
        let mut upwf1 = upwf1;
        upwf1.do_not_free_on_drop();
        let upwf1 = upwf1.ptr;
        let mut upwf2 = upwf2;
        upwf2.do_not_free_on_drop();
        let upwf2 = upwf2.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_fold(upwf1, upwf2) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_subtract_domain_union_set`.
    pub fn subtract_domain_union_set(self, uset: UnionSet) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwpq = self;
        let mut upwpq = upwpq;
        upwpq.do_not_free_on_drop();
        let upwpq = upwpq.ptr;
        let mut uset = uset;
        uset.do_not_free_on_drop();
        let uset = uset.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_subtract_domain_union_set(upwpq, uset) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_get_pw_qpolynomial_fold_list`.
    pub fn fold_get_pw_qpolynomial_fold_list(upwf: &UnionPwQPolynomialFold)
                                             -> PwQPolynomialFoldList {
        let upwf = upwf.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_fold_get_pw_qpolynomial_fold_list(upwf) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = PwQPolynomialFoldList { ptr: isl_rs_result,
                                                    should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_gist`.
    pub fn fold_gist(upwf: UnionPwQPolynomialFold, context: UnionSet) -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let mut context = context;
        context.do_not_free_on_drop();
        let context = context.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_gist(upwf, context) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_subtract_domain`.
    pub fn fold_subtract_domain(upwf: UnionPwQPolynomialFold, uset: UnionSet)
                                -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let mut uset = uset;
        uset.do_not_free_on_drop();
        let uset = uset.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_subtract_domain(upwf, uset) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_add`.
    pub fn add(self, upwqp2: UnionPwQPolynomial) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwqp1 = self;
        let mut upwqp1 = upwqp1;
        upwqp1.do_not_free_on_drop();
        let upwqp1 = upwqp1.ptr;
        let mut upwqp2 = upwqp2;
        upwqp2.do_not_free_on_drop();
        let upwqp2 = upwqp2.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_add(upwqp1, upwqp2) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_fold_pw_qpolynomial_fold`.
    pub fn fold_fold_pw_qpolynomial_fold(upwqp: UnionPwQPolynomialFold, pwqp: PwQPolynomialFold)
                                         -> UnionPwQPolynomialFold {
        let mut upwqp = upwqp;
        upwqp.do_not_free_on_drop();
        let upwqp = upwqp.ptr;
        let mut pwqp = pwqp;
        pwqp.do_not_free_on_drop();
        let pwqp = pwqp.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_fold_fold_pw_qpolynomial_fold(upwqp, pwqp) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_scale_val`.
    pub fn fold_scale_val(upwf: UnionPwQPolynomialFold, v: Val) -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let mut v = v;
        v.do_not_free_on_drop();
        let v = v.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_scale_val(upwf, v) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_add_pw_qpolynomial`.
    pub fn add_pw_qpolynomial(self, pwqp: PwQPolynomial) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let mut upwqp = upwqp;
        upwqp.do_not_free_on_drop();
        let upwqp = upwqp.ptr;
        let mut pwqp = pwqp;
        pwqp.do_not_free_on_drop();
        let pwqp = pwqp.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_add_pw_qpolynomial(upwqp, pwqp) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_subtract_domain_space`.
    pub fn fold_subtract_domain_space(upwf: UnionPwQPolynomialFold, space: Space)
                                      -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let mut space = space;
        space.do_not_free_on_drop();
        let space = space.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_fold_subtract_domain_space(upwf, space) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_intersect_params`.
    pub fn fold_intersect_params(upwf: UnionPwQPolynomialFold, set: Set) -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let mut set = set;
        set.do_not_free_on_drop();
        let set = set.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_intersect_params(upwf, set) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_intersect_params`.
    pub fn intersect_params(self, set: Set) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwpq = self;
        let mut upwpq = upwpq;
        upwpq.do_not_free_on_drop();
        let upwpq = upwpq.ptr;
        let mut set = set;
        set.do_not_free_on_drop();
        let set = set.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_intersect_params(upwpq, set) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_coalesce`.
    pub fn coalesce(self) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let mut upwqp = upwqp;
        upwqp.do_not_free_on_drop();
        let upwqp = upwqp.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_coalesce(upwqp) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_get_ctx`.
    pub fn get_ctx(&self) -> Context {
        let upwqp = self;
        let upwqp = upwqp.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_get_ctx(upwqp) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = Context { ptr: isl_rs_result,
                                      should_free_on_drop: true };
        let mut isl_rs_result = isl_rs_result;
        isl_rs_result.do_not_free_on_drop();
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_get_type`.
    pub fn fold_get_type(upwf: &UnionPwQPolynomialFold) -> Fold {
        let upwf = upwf.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_get_type(upwf) };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_scale_val`.
    pub fn scale_val(self, v: Val) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let mut upwqp = upwqp;
        upwqp.do_not_free_on_drop();
        let upwqp = upwqp.ptr;
        let mut v = v;
        v.do_not_free_on_drop();
        let v = v.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_scale_val(upwqp, v) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_intersect_domain_wrapped_domain`.
    pub fn intersect_domain_wrapped_domain(self, uset: UnionSet) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwpq = self;
        let mut upwpq = upwpq;
        upwpq.do_not_free_on_drop();
        let upwpq = upwpq.ptr;
        let mut uset = uset;
        uset.do_not_free_on_drop();
        let uset = uset.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_intersect_domain_wrapped_domain(upwpq, uset) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_subtract_domain`.
    pub fn subtract_domain(self, uset: UnionSet) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwpq = self;
        let mut upwpq = upwpq;
        upwpq.do_not_free_on_drop();
        let upwpq = upwpq.ptr;
        let mut uset = uset;
        uset.do_not_free_on_drop();
        let uset = uset.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_subtract_domain(upwpq, uset) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_zero`.
    pub fn zero(space: Space) -> UnionPwQPolynomial {
        let mut space = space;
        space.do_not_free_on_drop();
        let space = space.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_zero(space) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_scale_down_val`.
    pub fn fold_scale_down_val(upwf: UnionPwQPolynomialFold, v: Val) -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let mut v = v;
        v.do_not_free_on_drop();
        let v = v.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_scale_down_val(upwf, v) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_every_pw_qpolynomial`.
    pub fn every_pw_qpolynomial(&self,
                                test: unsafe extern "C" fn(uintptr_t, *mut c_void) -> i32,
                                user: *mut c_void)
                                -> bool {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let upwqp = upwqp.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_every_pw_qpolynomial(upwqp, test, user) };
        let isl_rs_result = match isl_rs_result {
            0 => false,
            1 => true,
            _ => panic!("ISL error: {}", context_for_error_message.last_error_msg()),
        };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_intersect_domain_wrapped_domain`.
    pub fn fold_intersect_domain_wrapped_domain(upwf: UnionPwQPolynomialFold, uset: UnionSet)
                                                -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let mut uset = uset;
        uset.do_not_free_on_drop();
        let uset = uset.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_fold_intersect_domain_wrapped_domain(upwf, uset) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_copy`.
    pub fn fold_copy(upwf: &UnionPwQPolynomialFold) -> UnionPwQPolynomialFold {
        let upwf = upwf.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_copy(upwf) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_zero`.
    pub fn fold_zero(space: Space, type_: Fold) -> UnionPwQPolynomialFold {
        let mut space = space;
        space.do_not_free_on_drop();
        let space = space.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_zero(space, type_) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_foreach_pw_qpolynomial_fold`.
    pub fn fold_foreach_pw_qpolynomial_fold(upwf: &UnionPwQPolynomialFold,
                                            fn_: unsafe extern "C" fn(uintptr_t,
                                                                 *mut c_void)
                                                                 -> Stat,
                                            user: *mut c_void)
                                            -> Stat {
        let upwf = upwf.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_fold_foreach_pw_qpolynomial_fold(upwf, fn_, user) };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_zero_space`.
    pub fn zero_space(space: Space) -> UnionPwQPolynomial {
        let mut space = space;
        space.do_not_free_on_drop();
        let space = space.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_zero_space(space) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_free`.
    pub fn free(self) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let mut upwqp = upwqp;
        upwqp.do_not_free_on_drop();
        let upwqp = upwqp.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_free(upwqp) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_get_pw_qpolynomial_list`.
    pub fn get_pw_qpolynomial_list(&self) -> PwQPolynomialList {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let upwqp = upwqp.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_get_pw_qpolynomial_list(upwqp) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = PwQPolynomialList { ptr: isl_rs_result,
                                                should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_intersect_domain_space`.
    pub fn fold_intersect_domain_space(upwf: UnionPwQPolynomialFold, space: Space)
                                       -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let mut space = space;
        space.do_not_free_on_drop();
        let space = space.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_fold_intersect_domain_space(upwf, space) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_zero_ctx`.
    pub fn zero_ctx(ctx: &Context) -> UnionPwQPolynomial {
        let ctx = ctx.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_zero_ctx(ctx) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_intersect_domain_union_set`.
    pub fn intersect_domain_union_set(self, uset: UnionSet) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwpq = self;
        let mut upwpq = upwpq;
        upwpq.do_not_free_on_drop();
        let upwpq = upwpq.ptr;
        let mut uset = uset;
        uset.do_not_free_on_drop();
        let uset = uset.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_intersect_domain_union_set(upwpq, uset) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_subtract_domain_union_set`.
    pub fn fold_subtract_domain_union_set(upwf: UnionPwQPolynomialFold, uset: UnionSet)
                                          -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let mut uset = uset;
        uset.do_not_free_on_drop();
        let uset = uset.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_fold_subtract_domain_union_set(upwf, uset) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_mul`.
    pub fn mul(self, upwqp2: UnionPwQPolynomial) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwqp1 = self;
        let mut upwqp1 = upwqp1;
        upwqp1.do_not_free_on_drop();
        let upwqp1 = upwqp1.ptr;
        let mut upwqp2 = upwqp2;
        upwqp2.do_not_free_on_drop();
        let upwqp2 = upwqp2.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_mul(upwqp1, upwqp2) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_get_space`.
    pub fn fold_get_space(upwf: &UnionPwQPolynomialFold) -> Space {
        let upwf = upwf.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_get_space(upwf) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = Space { ptr: isl_rs_result,
                                    should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_subtract_domain_space`.
    pub fn subtract_domain_space(self, space: Space) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwpq = self;
        let mut upwpq = upwpq;
        upwpq.do_not_free_on_drop();
        let upwpq = upwpq.ptr;
        let mut space = space;
        space.do_not_free_on_drop();
        let space = space.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_subtract_domain_space(upwpq, space) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_n_pw_qpolynomial`.
    pub fn n_pw_qpolynomial(&self) -> i32 {
        let upwqp = self;
        let upwqp = upwqp.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_n_pw_qpolynomial(upwqp) };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_gist_params`.
    pub fn fold_gist_params(upwf: UnionPwQPolynomialFold, context: Set) -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let mut context = context;
        context.do_not_free_on_drop();
        let context = context.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_gist_params(upwf, context) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_neg`.
    pub fn neg(self) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let mut upwqp = upwqp;
        upwqp.do_not_free_on_drop();
        let upwqp = upwqp.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_neg(upwqp) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_drop_dims`.
    pub fn fold_drop_dims(upwf: UnionPwQPolynomialFold, type_: DimType, first: u32, n: u32)
                          -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_fold_drop_dims(upwf, type_, first, n) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_to_str`.
    pub fn to_str(&self) -> &str {
        let upwqp = self;
        let upwqp = upwqp.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_to_str(upwqp) };
        let isl_rs_result = unsafe { CStr::from_ptr(isl_rs_result) };
        let isl_rs_result = isl_rs_result.to_str().unwrap();
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_intersect_domain_wrapped_range`.
    pub fn intersect_domain_wrapped_range(self, uset: UnionSet) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwpq = self;
        let mut upwpq = upwpq;
        upwpq.do_not_free_on_drop();
        let upwpq = upwpq.ptr;
        let mut uset = uset;
        uset.do_not_free_on_drop();
        let uset = uset.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_intersect_domain_wrapped_range(upwpq, uset) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_involves_nan`.
    pub fn involves_nan(&self) -> bool {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let upwqp = upwqp.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_involves_nan(upwqp) };
        let isl_rs_result = match isl_rs_result {
            0 => false,
            1 => true,
            _ => panic!("ISL error: {}", context_for_error_message.last_error_msg()),
        };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_add_union_pw_qpolynomial`.
    pub fn fold_add_union_pw_qpolynomial(upwf: UnionPwQPolynomialFold, upwqp: UnionPwQPolynomial)
                                         -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let mut upwqp = upwqp;
        upwqp.do_not_free_on_drop();
        let upwqp = upwqp.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_fold_add_union_pw_qpolynomial(upwf, upwqp) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_free`.
    pub fn fold_free(upwf: UnionPwQPolynomialFold) -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_free(upwf) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_reset_user`.
    pub fn fold_reset_user(upwf: UnionPwQPolynomialFold) -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_reset_user(upwf) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_scale_down_val`.
    pub fn scale_down_val(self, v: Val) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let mut upwqp = upwqp;
        upwqp.do_not_free_on_drop();
        let upwqp = upwqp.ptr;
        let mut v = v;
        v.do_not_free_on_drop();
        let v = v.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_scale_down_val(upwqp, v) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_drop_dims`.
    pub fn drop_dims(self, type_: DimType, first: u32, n: u32) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let mut upwqp = upwqp;
        upwqp.do_not_free_on_drop();
        let upwqp = upwqp.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_drop_dims(upwqp, type_, first, n) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_align_params`.
    pub fn align_params(self, model: Space) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let mut upwqp = upwqp;
        upwqp.do_not_free_on_drop();
        let upwqp = upwqp.ptr;
        let mut model = model;
        model.do_not_free_on_drop();
        let model = model.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_align_params(upwqp, model) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_dim`.
    pub fn dim(&self, type_: DimType) -> i32 {
        let upwqp = self;
        let upwqp = upwqp.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_dim(upwqp, type_) };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_plain_is_equal`.
    pub fn plain_is_equal(&self, upwqp2: &UnionPwQPolynomial) -> bool {
        let context_for_error_message = self.get_ctx();
        let upwqp1 = self;
        let upwqp1 = upwqp1.ptr;
        let upwqp2 = upwqp2.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_plain_is_equal(upwqp1, upwqp2) };
        let isl_rs_result = match isl_rs_result {
            0 => false,
            1 => true,
            _ => panic!("ISL error: {}", context_for_error_message.last_error_msg()),
        };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_eval`.
    pub fn eval(self, pnt: Point) -> Val {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let mut upwqp = upwqp;
        upwqp.do_not_free_on_drop();
        let upwqp = upwqp.ptr;
        let mut pnt = pnt;
        pnt.do_not_free_on_drop();
        let pnt = pnt.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_eval(upwqp, pnt) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = Val { ptr: isl_rs_result,
                                  should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_intersect_domain`.
    pub fn fold_intersect_domain(upwf: UnionPwQPolynomialFold, uset: UnionSet)
                                 -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let mut uset = uset;
        uset.do_not_free_on_drop();
        let uset = uset.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_intersect_domain(upwf, uset) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_foreach_pw_qpolynomial`.
    pub fn foreach_pw_qpolynomial(&self,
                                  fn_: unsafe extern "C" fn(uintptr_t, *mut c_void) -> Stat,
                                  user: *mut c_void)
                                  -> Stat {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let upwqp = upwqp.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_foreach_pw_qpolynomial(upwqp, fn_, user) };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_read_from_str`.
    pub fn read_from_str(ctx: &Context, str_: &str) -> UnionPwQPolynomial {
        let ctx = ctx.ptr;
        let str_ = CString::new(str_).unwrap();
        let str_ = str_.as_ptr();
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_read_from_str(ctx, str_) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_domain`.
    pub fn domain(self) -> UnionSet {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let mut upwqp = upwqp;
        upwqp.do_not_free_on_drop();
        let upwqp = upwqp.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_domain(upwqp) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionSet { ptr: isl_rs_result,
                                       should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_gist_params`.
    pub fn gist_params(self, context: Set) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let mut upwqp = upwqp;
        upwqp.do_not_free_on_drop();
        let upwqp = upwqp.ptr;
        let mut context = context;
        context.do_not_free_on_drop();
        let context = context.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_gist_params(upwqp, context) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_intersect_domain`.
    pub fn intersect_domain(self, uset: UnionSet) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwpq = self;
        let mut upwpq = upwpq;
        upwpq.do_not_free_on_drop();
        let upwpq = upwpq.ptr;
        let mut uset = uset;
        uset.do_not_free_on_drop();
        let uset = uset.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_intersect_domain(upwpq, uset) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_get_ctx`.
    pub fn fold_get_ctx(upwf: &UnionPwQPolynomialFold) -> Context {
        let upwf = upwf.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_get_ctx(upwf) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = Context { ptr: isl_rs_result,
                                      should_free_on_drop: true };
        let mut isl_rs_result = isl_rs_result;
        isl_rs_result.do_not_free_on_drop();
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_gist`.
    pub fn gist(self, context: UnionSet) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let mut upwqp = upwqp;
        upwqp.do_not_free_on_drop();
        let upwqp = upwqp.ptr;
        let mut context = context;
        context.do_not_free_on_drop();
        let context = context.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_gist(upwqp, context) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_intersect_domain_space`.
    pub fn intersect_domain_space(self, space: Space) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwpq = self;
        let mut upwpq = upwpq;
        upwpq.do_not_free_on_drop();
        let upwpq = upwpq.ptr;
        let mut space = space;
        space.do_not_free_on_drop();
        let space = space.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_intersect_domain_space(upwpq, space) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_get_space`.
    pub fn get_space(&self) -> Space {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let upwqp = upwqp.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_get_space(upwqp) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = Space { ptr: isl_rs_result,
                                    should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_reset_user`.
    pub fn reset_user(self) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let mut upwqp = upwqp;
        upwqp.do_not_free_on_drop();
        let upwqp = upwqp.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_reset_user(upwqp) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_involves_nan`.
    pub fn fold_involves_nan(upwf: &UnionPwQPolynomialFold) -> bool {
        let upwf = upwf.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_involves_nan(upwf) };
        let isl_rs_result = match isl_rs_result {
            0 => false,
            1 => true,
            _ => panic!("ISL error"),
        };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_intersect_domain_wrapped_range`.
    pub fn fold_intersect_domain_wrapped_range(upwf: UnionPwQPolynomialFold, uset: UnionSet)
                                               -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let mut uset = uset;
        uset.do_not_free_on_drop();
        let uset = uset.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_fold_intersect_domain_wrapped_range(upwf, uset) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_domain`.
    pub fn fold_domain(upwf: UnionPwQPolynomialFold) -> UnionSet {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_domain(upwf) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionSet { ptr: isl_rs_result,
                                       should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_n_pw_qpolynomial_fold`.
    pub fn fold_n_pw_qpolynomial_fold(upwf: &UnionPwQPolynomialFold) -> i32 {
        let upwf = upwf.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_n_pw_qpolynomial_fold(upwf) };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_from_pw_qpolynomial_fold`.
    pub fn fold_from_pw_qpolynomial_fold(pwf: PwQPolynomialFold) -> UnionPwQPolynomialFold {
        let mut pwf = pwf;
        pwf.do_not_free_on_drop();
        let pwf = pwf.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_from_pw_qpolynomial_fold(pwf) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_every_pw_qpolynomial_fold`.
    pub fn fold_every_pw_qpolynomial_fold(upwf: &UnionPwQPolynomialFold,
                                          test: unsafe extern "C" fn(uintptr_t,
                                                               *mut c_void)
                                                               -> i32,
                                          user: *mut c_void)
                                          -> bool {
        let upwf = upwf.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_fold_every_pw_qpolynomial_fold(upwf, test, user) };
        let isl_rs_result = match isl_rs_result {
            0 => false,
            1 => true,
            _ => panic!("ISL error"),
        };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_set_dim_name`.
    pub fn set_dim_name(self, type_: DimType, pos: u32, s: &str) -> UnionPwQPolynomial {
        let context_for_error_message = self.get_ctx();
        let upwqp = self;
        let mut upwqp = upwqp;
        upwqp.do_not_free_on_drop();
        let upwqp = upwqp.ptr;
        let s = CString::new(s).unwrap();
        let s = s.as_ptr();
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_set_dim_name(upwqp, type_, pos, s) };
        if isl_rs_result == 0 {
            panic!("ISL error: {}", context_for_error_message.last_error_msg());
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_plain_is_equal`.
    pub fn fold_plain_is_equal(upwf1: &UnionPwQPolynomialFold, upwf2: &UnionPwQPolynomialFold)
                               -> bool {
        let upwf1 = upwf1.ptr;
        let upwf2 = upwf2.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_plain_is_equal(upwf1, upwf2) };
        let isl_rs_result = match isl_rs_result {
            0 => false,
            1 => true,
            _ => panic!("ISL error"),
        };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_set_dim_name`.
    pub fn fold_set_dim_name(upwf: UnionPwQPolynomialFold, type_: DimType, pos: u32, s: &str)
                             -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let s = CString::new(s).unwrap();
        let s = s.as_ptr();
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_fold_set_dim_name(upwf, type_, pos, s) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_extract_pw_qpolynomial_fold`.
    pub fn fold_extract_pw_qpolynomial_fold(upwf: &UnionPwQPolynomialFold, space: Space)
                                            -> PwQPolynomialFold {
        let upwf = upwf.ptr;
        let mut space = space;
        space.do_not_free_on_drop();
        let space = space.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_fold_extract_pw_qpolynomial_fold(upwf, space) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = PwQPolynomialFold { ptr: isl_rs_result,
                                                should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_from_pw_qpolynomial`.
    pub fn from_pw_qpolynomial(pwqp: PwQPolynomial) -> UnionPwQPolynomial {
        let mut pwqp = pwqp;
        pwqp.do_not_free_on_drop();
        let pwqp = pwqp.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_from_pw_qpolynomial(pwqp) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomial { ptr: isl_rs_result,
                                                 should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_zero_space`.
    pub fn fold_zero_space(space: Space, type_: Fold) -> UnionPwQPolynomialFold {
        let mut space = space;
        space.do_not_free_on_drop();
        let space = space.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_zero_space(space, type_) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_align_params`.
    pub fn fold_align_params(upwf: UnionPwQPolynomialFold, model: Space) -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let mut model = model;
        model.do_not_free_on_drop();
        let model = model.ptr;
        let isl_rs_result = unsafe { isl_union_pw_qpolynomial_fold_align_params(upwf, model) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_intersect_domain_union_set`.
    pub fn fold_intersect_domain_union_set(upwf: UnionPwQPolynomialFold, uset: UnionSet)
                                           -> UnionPwQPolynomialFold {
        let mut upwf = upwf;
        upwf.do_not_free_on_drop();
        let upwf = upwf.ptr;
        let mut uset = uset;
        uset.do_not_free_on_drop();
        let uset = uset.ptr;
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_fold_intersect_domain_union_set(upwf, uset) };
        if isl_rs_result == 0 {
            panic!("ISL error");
        }
        let isl_rs_result = UnionPwQPolynomialFold { ptr: isl_rs_result,
                                                     should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_pw_qpolynomial_fold_find_dim_by_name`.
    pub fn fold_find_dim_by_name(upwf: &UnionPwQPolynomialFold, type_: DimType, name: &str) -> i32 {
        let upwf = upwf.ptr;
        let name = CString::new(name).unwrap();
        let name = name.as_ptr();
        let isl_rs_result =
            unsafe { isl_union_pw_qpolynomial_fold_find_dim_by_name(upwf, type_, name) };
        isl_rs_result
    }

    /// Does not call isl_xxx_free() on being dropped. (For internal use only.)
    pub fn do_not_free_on_drop(&mut self) {
        self.should_free_on_drop = false;
    }
}

impl Drop for UnionPwQPolynomial {
    fn drop(&mut self) {
        if self.should_free_on_drop {
            unsafe {
                isl_union_pw_qpolynomial_free(self.ptr);
            }
        }
    }
}
